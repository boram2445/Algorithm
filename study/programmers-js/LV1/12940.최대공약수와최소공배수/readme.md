## 1. 문제

- 상태 : 스스로 품
- 난이도 : ⭐⭐⭐

### **문제 설명**

두 수를 입력받아 두 수의 최대공약수와 최소공배수를 반환하는 함수, solution을 완성해 보세요. 배열의 맨 앞에 최대공약수, 그다음 최소공배수를 넣어 반환하면 됩니다. 예를 들어 두 수 3, 12의 최대공약수는 3, 최소공배수는 12이므로 solution(3, 12)는 [3, 12]를 반환해야 합니다.

### 제한 사항

- 두 수는 1이상 1000000이하의 자연수입니다.

### 입출력 예

| n   | m   | return  |
| --- | --- | ------- |
| 3   | 12  | [3, 12] |
| 2   | 5   | [1, 10] |

## 2. 내 풀이

- 처음에 최대공약수, 최소공배수의 개념이 기억이 안나서 당황스러웠고, 도대체 이걸 어떻게 구해야 하나 하고 포기하고 구글링 해보려고 했다.
- 약수를 구하는 법은, 1까지 for문을 돌리면서 나머지가 0일때 약수가 되는 것인데,
- 최대공약수도 마찬가지라고 생각이 들어서, **최대공약수가 될 수 있는 가장 큰 값부터, 1까지 for문을 돌리며 찾도록 하였다**.
- 그리고 최소공배수는 노트에 여러번 계산해보니, **각 값을 최대공약수로 나누고 그 곱에 최대공약수를 곱하면** 나오는 것이었다.
- 사실 원래 이렇게 푸는 지는 모르겠지만, 끝까지 해결하려고 애썼다는 것에 뿌듯하다.

```jsx
function solution(n, m) {
  let res1;
  let res2;
  //최대공약수
  for (let i = Math.min(n, m); i >= 1; i--) {
    if (n % i === 0 && m % i === 0) {
      res1 = i;
      break;
    }
  }
  //최소공배수
  res2 = res1 * (n / res1) * (m / res1);
  return [res1, res2];
}
```

## 3. 배운점

- **최대공약수, 최소공배수 알고리즘**
  - **최대공약수** (소름이다 내코드랑 거의 비슷,, (for문을 더 적게 돌 수 있으니 내코드가 더 좋은것 같기도))
  ```jsx
  let getGCD = (num1, num2) => {
    let gcd = 1;

    for (let i = 2; i <= Math.min(num1, num2); i++) {
      if (num1 % i === 0 && num2 % i === 0) {
        gcd = i;
      }
    }

    return gcd;
  };
  ```
- **최소공배수**
  - lcm을 1부터 시작하여 점차 lcm++하면서 각각의 두 수를 lcm으로 나누었을때 나머지 값이 0인지를 비교한다.
  - **최대공약수는 주어진 값에서 나누었다면 이건, 주어진 수로 나누는 방법이구나!!**
  (그냥 lcm을 둘중 최솟값으로 하고 시작하면 안되남ㅋㅋ)
  ```jsx
  let getLCM = (num1, num2) => {
    let lcm = 1;

    while (true) {
      if (lcm % num1 == 0 && lcm % num2 == 0) {
        break;
      }
      lcm++;
    }
    return lcm;
  };
  ```
